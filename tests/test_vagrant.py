"""
Introduces setup and teardown routines suitable for testing Vagrant.

Note that the tests can take few minutes to run because of the time
required to bring up/down the VM.

Most test functions (decorated with `@with_setup`) will actually bring the VM
up/down. This is the "proper" way of doing things (isolation).  However, the
downside of such a workflow is that it increases the execution time of the test
suite.

Before the first test a base box is added to Vagrant under the name
TEST_BOX_NAME. This box is not deleted after the test suite runs in order
to avoid downloading of the box file on every run.
"""

from __future__ import print_function
import os
import shutil
import subprocess  # noqa
import sys
import tempfile
import time
from nose.tools import eq_, ok_, with_setup, assert_raises

import vagrant
from vagrant import compat

# location of a test file on the created box by provisioning in vm_Vagrantfile
TEST_FILE_PATH = "/home/vagrant/python_vagrant_test_file"
# location of Vagrantfiles used for testing.
MULTIVM_VAGRANTFILE = os.path.join(
    os.path.dirname(os.path.abspath(__file__)), "vagrantfiles", "multivm_Vagrantfile"
)
VM_VAGRANTFILE = os.path.join(
    os.path.dirname(os.path.abspath(__file__)), "vagrantfiles", "vm_Vagrantfile"
)
SHELL_PROVISION_VAGRANTFILE = os.path.join(
    os.path.dirname(os.path.abspath(__file__)),
    "vagrantfiles",
    "shell_provision_Vagrantfile",
)
# the names of the vms from the multi-vm Vagrantfile.
VM_1 = "web"
VM_2 = "db"
# name of the base box used for testing
TEST_BOX_NAME = "python-vagrant-base"
# url of the box file used for testing
TEST_BOX_URL = "https://app.vagrantup.com/ubuntu/boxes/focal64/versions/20210907.0.0/providers/virtualbox.box"
# temp dir for testing.
TD = None


def list_box_names():
    """
    Return a list of the currently installed vagrant box names.  This is
    implemented outside of `vagrant.Vagrant`, so that it will still work
    even if the `Vagrant.box_list()` implementation is broken.
    """
    listing = compat.decode(
        subprocess.check_output(  # noqa
            "vagrant box list --machine-readable", shell=True  # noqa
        )
    )
    box_names = []
    for line in listing.splitlines():
        # Vagrant 1.8 added additional fields to the --machine-readable output,
        # so unpack the fields according to the number of separators found.
        if line.count(",") == 3:
            _timestamp, _, kind, data = line.split(",")
        else:
            _timestamp, _, kind, data, _extra_data = line.split(",")
        if kind == "box-name":
            box_names.append(data.strip())
    return box_names


# MODULE-LEVEL SETUP AND TEARDOWN


def setup():
    """
    Creates the directory used for testing and sets up the base box if not
    already set up.

    Creates a directory in a temporary location and checks if there is a base
    box under the `TEST_BOX_NAME`. If not, downloads it from `TEST_BOX_URL` and
    adds to Vagrant.

    This is ran once before the first test (global setup).
    """
    sys.stderr.write("module setup()\n")
    global TD
    TD = tempfile.mkdtemp()
    sys.stderr.write("test temp dir: {}\n".format(TD))
    boxes = list_box_names()
    if TEST_BOX_NAME not in boxes:
        cmd = f"vagrant box add {TEST_BOX_NAME} {TEST_BOX_URL}"
        subprocess.check_call(cmd, shell=True)  # noqa


def teardown():
    """
    Removes the directory created in setup.

    This is run once after the last test.
    """
    sys.stderr.write("module teardown()\n")
    if TD is not None:
        shutil.rmtree(TD)


# TEST-LEVEL SETUP AND TEARDOWN


def make_setup_vm(vagrantfile=None):
    """
    Make and return a function that sets up the temporary directory with a
    Vagrantfile.  By default, use VM_VAGRANTFILE.
    vagrantfile: path to a vagrantfile to use as Vagrantfile in the testing temporary directory.
    """
    if vagrantfile is None:
        vagrantfile = VM_VAGRANTFILE

    def setup_vm():
        shutil.copy(vagrantfile, os.path.join(TD, "Vagrantfile"))

    return setup_vm


def teardown_vm():
    """
    Attempts to destroy every VM in the Vagrantfile in the temporary directory, TD.
    It is not an error if a VM has already been destroyed.
    """
    try:
        # Try to destroy any vagrant box that might be running.
        subprocess.check_call("vagrant destroy -f", cwd=TD, shell=True)  # noqa
    except subprocess.CalledProcessError:
        pass
    finally:
        # remove Vagrantfile created by setup.
        os.unlink(os.path.join(TD, "Vagrantfile"))


@with_setup(make_setup_vm(), teardown_vm)
def test_parse_plugin_list():
    """
    Test the parsing the output of the `vagrant plugin list` command.
    """
    # listing should match output generated by `vagrant plugin list`.
    listing = """1424145521,,plugin-name,sahara
1424145521,sahara,plugin-version,0.0.16
1424145521,,plugin-name,vagrant-share
1424145521,vagrant-share,plugin-version,1.1.3%!(VAGRANT_COMMA) system
"""
    # Can compare tuples to Plugin class b/c Plugin is a collections.namedtuple.
    goal = [("sahara", "0.0.16", False), ("vagrant-share", "1.1.3", True)]
    vexe = vagrant.Vagrant(TD)
    parsed = vexe._parse_plugin_list(listing)
    assert (
        goal == parsed
    ), "The parsing of the test listing did not match the goal.\nlisting={!r}\ngoal={!r}\nparsed_listing={!r}".format(
        listing, goal, parsed
    )


@with_setup(make_setup_vm(), teardown_vm)
def test_parse_box_list():
    """
    Test the parsing the output of the `vagrant box list` command.
    """
    listing = """1424141572,,box-name,focal64
1424141572,,box-provider,virtualbox
1424141572,,box-version,0
1424141572,,box-name,python-vagrant-base
1424141572,,box-provider,virtualbox
1424141572,,box-version,0
"""
    # Can compare tuples to Box class b/c Box is a collections.namedtuple.
    goal = [
        ("focal64", "virtualbox", "0"),
        ("python-vagrant-base", "virtualbox", "0"),
    ]
    vexe = vagrant.Vagrant(TD)
    parsed = vexe._parse_box_list(listing)
    assert (
        goal == parsed
    ), "The parsing of the test listing did not match the goal.\nlisting={!r}\ngoal={!r}\nparsed_listing={!r}".format(
        listing, goal, parsed
    )


@with_setup(make_setup_vm(), teardown_vm)
def test_parse_status():
    """
    Test the parsing the output of the `vagrant status` command.
    """
    listing = """1424098924,web,provider-name,virtualbox
1424098924,web,state,running
1424098924,web,state-human-short,running
1424098924,web,state-human-long,The VM is running. To stop this VM%!(VAGRANT_COMMA) you can run `vagrant halt` to\\nshut it down forcefully%!(VAGRANT_COMMA) or you can run `vagrant suspend` to simply\\nsuspend the virtual machine. In either case%!(VAGRANT_COMMA) to restart it again%!(VAGRANT_COMMA)\\nsimply run `vagrant up`.
1424098924,db,provider-name,virtualbox
1424098924,db,state,not_created
1424098924,db,state-human-short,not created
1424098924,db,state-human-long,The environment has not yet been created. Run `vagrant up` to\\ncreate the environment. If a machine is not created%!(VAGRANT_COMMA) only the\\ndefault provider will be shown. So if a provider is not listed%!(VAGRANT_COMMA)\\nthen the machine is not created for that environment.
"""
    # Can compare tuples to Status class b/c Status is a collections.namedtuple.
    goal = [("web", "running", "virtualbox"), ("db", "not_created", "virtualbox")]
    vexe = vagrant.Vagrant(TD)
    parsed = vexe._parse_status(listing)
    assert (
        goal == parsed
    ), "The parsing of the test listing did not match the goal.\nlisting={!r}\ngoal={!r}\nparsed_listing={!r}".format(
        listing, goal, parsed
    )


@with_setup(make_setup_vm(), teardown_vm)
def test_parse_aws_status():
    """
    Test the parsing the output of the `vagrant status` command for an aws instance.
    """
    listing = """1462351212,default,action,read_state,start
1462351214,default,action,read_state,end
1462351214,default,metadata,provider,aws
1462351214,default,action,read_state,start
1462351215,default,action,read_state,end
1462351215,default,action,read_state,start
1462351216,default,action,read_state,end
1462351216,default,action,read_state,start
1462351217,default,action,read_state,end
1462351217,default,provider-name,aws
1462351217,default,state,running
1462351217,default,state-human-short,running
1462351217,default,state-human-long,The EC2 instance is running. To stop this machine%!(VAGRANT_COMMA) you can run\\n`vagrant halt`. To destroy the machine%!(VAGRANT_COMMA) you can run `vagrant destroy`.
1462351217,default,action,read_state,start
1462351219,default,action,read_state,end
1462351219,,ui,info,Current machine states:\\n\\ndefault (aws)\\n\\nThe EC2 instance is running. To stop this machine%!(VAGRANT_COMMA) you can run\\n`vagrant halt`. To destroy the machine%!(VAGRANT_COMMA) you can run `vagrant destroy`.
"""
    # Can compare tuples to Status class b/c Status is a collections.namedtuple.
    goal = [("default", "running", "aws")]
    vexe = vagrant.Vagrant(TD)
    parsed = vexe._parse_status(listing)
    assert (
        goal == parsed
    ), "The parsing of the test listing did not match the goal.\nlisting={!r}\ngoal={!r}\nparsed_listing={!r}".format(
        listing, goal, parsed
    )


@with_setup(make_setup_vm(), teardown_vm)
def test_vm_status():
    """
    Test whether vagrant.status() correctly reports state of the VM, in a
    single-VM environment.
    """
    vexe = vagrant.Vagrant(TD)
    assert (
        vexe.NOT_CREATED == vexe.status()[0].state
    ), "Before going up status should be vagrant.NOT_CREATED"
    command = "vagrant up"
    subprocess.check_call(command, cwd=TD, shell=True)  # noqa
    assert (
        vexe.RUNNING in vexe.status()[0].state
    ), "After going up status should be vagrant.RUNNING"

    command = "vagrant halt"
    subprocess.check_call(command, cwd=TD, shell=True)  # noqa
    assert (
        vexe.POWEROFF in vexe.status()[0].state
    ), "After halting status should be vagrant.POWEROFF"

    command = "vagrant destroy -f"
    subprocess.check_call(command, cwd=TD, shell=True)  # noqa
    assert (
        vexe.NOT_CREATED in vexe.status()[0].state
    ), "After destroying status should be vagrant.NOT_CREATED"


@with_setup(make_setup_vm(), teardown_vm)
def test_vm_lifecycle():
    """
    Test methods controlling the VM - init(), up(), halt(), destroy().
    """

    vexe = vagrant.Vagrant(TD)

    # Test init by removing Vagrantfile, since v.init() will create one.
    os.unlink(os.path.join(TD, "Vagrantfile"))
    vexe.init(TEST_BOX_NAME)
    assert vexe.NOT_CREATED == vexe.status()[0].state

    vexe.up()
    assert vexe.RUNNING == vexe.status()[0].state

    vexe.suspend()
    assert vexe.SAVED == vexe.status()[0].state

    vexe.halt()
    assert vexe.POWEROFF == vexe.status()[0].state

    vexe.destroy()
    assert vexe.NOT_CREATED == vexe.status()[0].state


@with_setup(make_setup_vm(), teardown_vm)
def test_vm_config():
    """
    Test methods retrieving ssh config settings, like user, hostname, and port.
    """
    vexe = vagrant.Vagrant(TD)
    vexe.up()
    command = "vagrant ssh-config"
    ssh_config = compat.decode(  # noqa
        subprocess.check_output(command, cwd=TD, shell=True)  # noqa
    )
    parsed_config = dict(
        line.strip().split(None, 1)
        for line in ssh_config.splitlines()
        if line.strip() and not line.strip().startswith("#")
    )

    user = vexe.user()
    expected_user = parsed_config["User"]
    eq_(user, expected_user)

    hostname = vexe.hostname()
    expected_hostname = parsed_config["HostName"]
    eq_(hostname, expected_hostname)

    port = vexe.port()
    expected_port = parsed_config["Port"]
    eq_(port, expected_port)

    user_hostname = vexe.user_hostname()
    eq_(user_hostname, "{}@{}".format(expected_user, expected_hostname))

    user_hostname_port = vexe.user_hostname_port()
    eq_(
        user_hostname_port,
        "{}@{}:{}".format(expected_user, expected_hostname, expected_port),
    )

    keyfile = vexe.keyfile()
    try:
        eq_(keyfile, parsed_config["IdentityFile"])
    except AssertionError:
        # Vagrant 1.8 adds quotes around the filepath for the private key.
        eq_(keyfile, parsed_config["IdentityFile"].lstrip('"').rstrip('"'))


@with_setup(make_setup_vm(), teardown_vm)
def test_vm_sandbox_mode():
    """
    Test methods for enabling/disabling the sandbox mode
    and committing/rolling back changes.

    This depends on the Sahara plugin.
    """
    # Only test Sahara if it is installed.
    # This leaves the testing of Sahara to people who care.
    sahara_installed = _plugin_installed(vagrant.Vagrant(TD), "sahara")
    if not sahara_installed:
        return

    vexe = vagrant.SandboxVagrant(TD)

    sandbox_status = vexe.sandbox_status()
    assert (
        sandbox_status == "unknown"
    ), "Before the VM goes up the status should be 'unknown', " + "got:'{}'".format(
        sandbox_status
    )

    vexe.up()
    sandbox_status = vexe.sandbox_status()
    assert (
        sandbox_status == "off"
    ), "After the VM goes up the status should be 'off', " + "got:'{}'".format(
        sandbox_status
    )

    vexe.sandbox_on()
    sandbox_status = vexe.sandbox_status()
    assert sandbox_status == "on", (
        "After enabling the sandbox mode the status should be 'on', "
        + "got:'{}'".format(sandbox_status)
    )

    vexe.sandbox_off()
    sandbox_status = vexe.sandbox_status()
    assert sandbox_status == "off", (
        "After disabling the sandbox mode the status should be 'off', "
        + "got:'{}'".format(sandbox_status)
    )

    vexe.sandbox_on()
    vexe.halt()
    sandbox_status = vexe.sandbox_status()
    assert (
        sandbox_status == "on"
    ), "After halting the VM the status should be 'on', " + "got:'{}'".format(
        sandbox_status
    )

    vexe.up()
    sandbox_status = vexe.sandbox_status()
    assert sandbox_status == "on", (
        "After bringing the VM up again the status should be 'on', "
        + "got:'{}'".format(sandbox_status)
    )

    test_file_contents = _read_test_file(vexe)
    print(test_file_contents)
    eq_(test_file_contents, None, "There should be no test file")

    _write_test_file(vagrant, "foo")
    test_file_contents = _read_test_file(vexe)
    print(test_file_contents)
    eq_(test_file_contents, "foo", "The test file should read 'foo'")

    vexe.sandbox_rollback()
    time.sleep(10)  # https://github.com/jedi4ever/sahara/issues/16

    test_file_contents = _read_test_file(vexe)
    print(test_file_contents)
    eq_(test_file_contents, None, "There should be no test file")

    _write_test_file(vagrant, "foo")
    test_file_contents = _read_test_file(vexe)
    print(test_file_contents)
    eq_(test_file_contents, "foo", "The test file should read 'foo'")
    vexe.sandbox_commit()
    _write_test_file(vagrant, "bar")
    test_file_contents = _read_test_file(vexe)
    print(test_file_contents)
    eq_(test_file_contents, "bar", "The test file should read 'bar'")

    vexe.sandbox_rollback()
    time.sleep(10)  # https://github.com/jedi4ever/sahara/issues/16

    test_file_contents = _read_test_file(vexe)
    print(test_file_contents)
    eq_(test_file_contents, "foo", "The test file should read 'foo'")

    sandbox_status = vexe._parse_vagrant_sandbox_status("Usage: ...")
    eq_(
        sandbox_status,
        "not installed",
        "When 'vagrant sandbox status'"
        + " outputs vagrant help status should be 'not installed', "
        + "got:'{}'".format(sandbox_status),
    )

    vexe.destroy()
    sandbox_status = vexe.sandbox_status()
    assert (
        sandbox_status == "unknown"
    ), "After destroying the VM the status should be 'unknown', " + "got:'{}'".format(
        sandbox_status
    )


@with_setup(make_setup_vm(), teardown_vm)
def test_boxes():
    """
    Test methods for manipulating boxes - adding, listing, removing.
    """
    vexe = vagrant.Vagrant(TD)
    vagrant_exe = vagrant.get_vagrant_executable()
    box_name = "python-vagrant-dummy-box"
    provider = "virtualbox"

    # Start fresh with no dummy box
    if box_name in list_box_names():
        subprocess.check_call([vagrant_exe, "box", "remove", box_name])

    # Test that there is no dummy box listed
    ok_(
        box_name not in [b.name for b in vexe.box_list()],
        "There should be no dummy box before it's added.",
    )

    # Add a box
    vexe.box_add(box_name, TEST_BOX_URL)

    # Test that there is a dummy box listed
    box_listing = vexe.box_list()
    ok_(
        (box_name, provider) in [(b.name, b.provider) for b in box_listing],
        f"The box {box_name} for provider {provider} should be in the list returned by box_list(). box_list()={box_listing}".format(
            box=box_name, provider=provider, box_ddlisting=box_listing
        ),
    )

    # Remove dummy box using a box name and provider
    vexe.box_remove(box_name, provider)

    # Test that there is no dummy box listed
    ok_(
        box_name not in [b.name for b in vexe.box_list()],
        "There should be no dummy box after it has been removed.",
    )


@with_setup(make_setup_vm(SHELL_PROVISION_VAGRANTFILE), teardown_vm)
def test_provisioning():
    """
    Test provisioning support.  The tested provision config creates a file on
    the vm with the contents 'foo'.
    """
    vexe = vagrant.Vagrant(TD)

    vexe.up(no_provision=True)
    test_file_contents = _read_test_file(vexe)
    eq_(test_file_contents, None, "There should be no test file after up()")

    vexe.provision()
    test_file_contents = _read_test_file(vexe)
    print("Contents: f{test_file_contents}")
    eq_(test_file_contents, "foo", "The test file should contain 'foo'")


@with_setup(make_setup_vm(MULTIVM_VAGRANTFILE), teardown_vm)
def test_multivm_lifecycle():
    """Lifecycle walk."""
    vexe = vagrant.Vagrant(TD)

    # test getting multiple statuses at once
    eq_(vexe.status(VM_1)[0].state, vexe.NOT_CREATED)
    eq_(vexe.status(VM_2)[0].state, vexe.NOT_CREATED)

    vexe.up(vm_name=VM_1)
    eq_(vexe.status(VM_1)[0].state, vexe.RUNNING)
    eq_(vexe.status(VM_2)[0].state, vexe.NOT_CREATED)

    # start both vms
    vexe.up()
    eq_(vexe.status(VM_1)[0].state, vexe.RUNNING)
    eq_(vexe.status(VM_2)[0].state, vexe.RUNNING)

    vexe.halt(vm_name=VM_1)
    eq_(vexe.status(VM_1)[0].state, vexe.POWEROFF)
    eq_(vexe.status(VM_2)[0].state, vexe.RUNNING)

    vexe.destroy(vm_name=VM_1)
    eq_(vexe.status(VM_1)[0].state, vexe.NOT_CREATED)
    eq_(vexe.status(VM_2)[0].state, vexe.RUNNING)

    vexe.suspend(vm_name=VM_2)
    eq_(vexe.status(VM_1)[0].state, vexe.NOT_CREATED)
    eq_(vexe.status(VM_2)[0].state, vexe.SAVED)

    vexe.destroy(vm_name=VM_2)
    eq_(vexe.status(VM_1)[0].state, vexe.NOT_CREATED)
    eq_(vexe.status(VM_2)[0].state, vexe.NOT_CREATED)


@with_setup(make_setup_vm(MULTIVM_VAGRANTFILE), teardown_vm)
def test_multivm_config():
    """
    Test methods retrieving configuration settings.
    """
    vexe = vagrant.Vagrant(TD, quiet_stdout=False, quiet_stderr=False)
    vexe.up(vm_name=VM_1)
    command = "vagrant ssh-config " + VM_1
    ssh_config = compat.decode(
        subprocess.check_output(command, cwd=TD, shell=True)
    )  # noqa
    parsed_config = dict(
        line.strip().split(None, 1)
        for line in ssh_config.splitlines()
        if line.strip() and not line.strip().startswith("#")
    )

    user = vexe.user(vm_name=VM_1)
    expected_user = parsed_config["User"]
    eq_(user, expected_user)

    hostname = vexe.hostname(vm_name=VM_1)
    expected_hostname = parsed_config["HostName"]
    eq_(hostname, expected_hostname)

    port = vexe.port(vm_name=VM_1)
    expected_port = parsed_config["Port"]
    eq_(port, expected_port)

    user_hostname = vexe.user_hostname(vm_name=VM_1)
    eq_(user_hostname, f"{expected_user}@{expected_hostname}")

    user_hostname_port = vexe.user_hostname_port(vm_name=VM_1)
    eq_(
        user_hostname_port,
        f"{expected_user}@{expected_hostname}:{expected_port}",
    )

    keyfile = vexe.keyfile(vm_name=VM_1)
    try:
        eq_(keyfile, parsed_config["IdentityFile"])
    except AssertionError:
        # Vagrant 1.8 adds quotes around the filepath for the private key.
        eq_(keyfile, parsed_config["IdentityFile"].lstrip('"').rstrip('"'))


@with_setup(make_setup_vm(), teardown_vm)
def test_ssh_command():
    """
    Test executing a command via ssh on a vm.
    """
    vexe = vagrant.Vagrant(TD)
    vexe.up()
    output = vexe.ssh(command="lsb_release -is")
    assert output.strip() == "Ubuntu"


@with_setup(make_setup_vm(), teardown_vm)
def fail_test_ssh_command():
    """
    Fail a test executing a command via ssh on a vm.
    """
    vexe = vagrant.Vagrant(TD)
    vexe.up()
    output = vexe.ssh(command="lsb_release -is")
    assert not output.strip() == "Debian"


@with_setup(make_setup_vm(), teardown_vm)
def test_ssh_command_one_option():
    """
    Test executing a command via ssh on a vm with one extra ssh option
    """
    vexe = vagrant.Vagrant(TD)
    vexe.up()
    # Using an argument that won't change the behavior of ssh
    output = vexe.ssh(command="id -u", extra_ssh_args="-4")
    assert output.strip() == "1000"


@with_setup(make_setup_vm(), teardown_vm)
def test_ssh_command_one_option_with_parameter():
    """
    Test executing a command via ssh on a vm with one extra ssh argument that takes a parameter.
    """
    vexe = vagrant.Vagrant(TD)
    vexe.up()
    # Using an argument that won't change the behavior of ssh
    output = vexe.ssh(command="id -u", extra_ssh_args="-l vagrant")
    assert output.strip() == "1000"


@with_setup(make_setup_vm(), teardown_vm)
def test_ssh_command_multiple_options():
    """
    Test executing a command via ssh on a vm with two extra ssh arguments.
    """
    vexe = vagrant.Vagrant(TD)
    vexe.up()
    # Using arguments that won't change the behavior of ssh
    output = vexe.ssh(command="id -u", extra_ssh_args="-l vagrant -4 -a")
    assert output.strip() == "1000"


@with_setup(make_setup_vm(MULTIVM_VAGRANTFILE), teardown_vm)
def test_ssh_command_multivm():
    """
    Test executing a command via ssh on a specific vm
    """
    vexe = vagrant.Vagrant(TD)
    vexe.up()
    output = vexe.ssh(vm_name=VM_1, command="lsb_release -is")
    assert output.strip() == "Ubuntu"
    output = vexe.ssh(vm_name=VM_2, command="lsb_release -is")
    assert output.strip() == "Ubuntu"


@with_setup(make_setup_vm(), teardown_vm)
def test_streaming_output():
    """
    Test streaming output of up or reload.
    """
    test_string = "Waiting for machine to boot."
    vexe = vagrant.Vagrant(TD)

    with assert_raises(subprocess.CalledProcessError):
        vexe.up(vm_name="incorrect-name")

    streaming_up = False
    for line in vexe.up(stream_output=True):
        print("output line:", line)
        if test_string in line:
            streaming_up = True

    assert streaming_up

    streaming_reload = False
    for line in vexe.reload(stream_output=True):
        print("output line:", line)
        if test_string in line:
            streaming_reload = True

    assert streaming_reload


def test_make_file_cm():
    """Write file yielded by ContextManager."""
    filename = os.path.join(TD, "test.log")
    if os.path.exists(filename):
        os.remove(filename)

    # Test writing to the filehandle yielded by manager
    manager = vagrant.make_file_cm(filename)
    with manager() as filehandle:
        filehandle.write("one\n")

    with open(filename, encoding="UTF-8") as read_filehandle:
        assert read_filehandle.read() == "one\n"

    # Test appending to the file yielded by manager
    with manager() as filehandle:
        filehandle.write("two\n")

    with open(filename, encoding="UTF-8") as read_filehandle:
        assert read_filehandle.read() == "one\ntwo\n"


def _execute_command_in_vm(vexe, command):
    """
    Run command via ssh on the test vagrant box.  Returns a tuple of the
    return code and output of the command.
    """
    vagrant_exe = vagrant.get_vagrant_executable()

    if not vagrant_exe:
        raise RuntimeError(vagrant.VAGRANT_NOT_FOUND_WARNING)

    # ignore the fact that this host is not in our known hosts
    ssh_command = [vagrant_exe, "ssh", "-c", command]
    return compat.decode(subprocess.check_output(ssh_command, cwd=vexe.root))


def _write_test_file(vexe, file_contents):
    """
    Writes given contents to the test file.
    """
    command = f"echo '{file_contents}' > {TEST_FILE_PATH}"
    _execute_command_in_vm(vexe, command)


def _read_test_file(vagrant_vm):
    """
    Returns the contents of the test file stored in the VM or None if there
    is no file.
    """
    command = f"cat {TEST_FILE_PATH}"
    try:
        output = _execute_command_in_vm(vagrant_vm, command)
        return output.strip()
    except subprocess.CalledProcessError:
        return None


def _plugin_installed(vexe, plugin_name):
    plugins = vexe.plugin_list()
    return plugin_name in [plugin.name for plugin in plugins]
